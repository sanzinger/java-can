package at.sanzinger.can.modela;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.IdentityHashMap;

import at.sanzinger.can.Log;
import at.sanzinger.can.message.AnonymousConstant;
import at.sanzinger.can.message.ByteSpec;
import at.sanzinger.can.message.ConstantByteSpec;
import at.sanzinger.can.message.VariableByteSpec;

/**
 * General Format (20 bytes fixed size message block)
 * <pre>
 * ,---,----------- Start sequence, consumed/generated by {@link ModelAAdapter}
 * |   |  ,-------- Message type (01: data, 02: config)
 * |   |  | ,---------------------------------------------,--- Payload
 * |   |  | |                                             |  ,- Checksum
 * AA 55 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 	
 * </pre>
 */
public abstract class ModelAMessageType<T extends ModelAMessage<?>> {
	public static final ConstantByteSpec HEADER;
	public static final VariableByteSpec MESSAGE_TYPE;
	
	public static final ByteSpec[] SPEC = new ByteSpec[] {
		HEADER       = new ConstantByteSpec("HEADER",       null, c(2), 0x55AA),
		MESSAGE_TYPE = new VariableByteSpec("MESSAGE_TYPE", HEADER, c(1)),
	};
	
	protected ModelAMessageType() {
	}
	
	protected static AnonymousConstant c(long i) {
		return new AnonymousConstant(i);
	}
	
	public abstract ByteSpec[] getByteSpec();
	
	protected void setConstant(ByteBuffer buff) {
		for(ByteSpec s : getByteSpec()) {
			if(s instanceof ConstantByteSpec) {
				((ConstantByteSpec) s).emit(buff);
			}
		}
	}
	
	protected static ByteSpec[] extend(ByteSpec[] parent, ByteSpec ... specs) {
		ArrayList<ByteSpec> extended = new ArrayList<>(parent.length + specs.length);
		IdentityHashMap<ByteSpec, ByteSpec> constantOverwrite = new IdentityHashMap<>();
		for(ByteSpec s : specs) {
			if(s instanceof ConstantByteSpec) {
				VariableByteSpec constantOf = ((ConstantByteSpec)s).getConstantOf();
				if(constantOf != null) {					
					constantOverwrite.put(constantOf, s);
				}
			}
		}
		ByteSpec last = specs[specs.length-1];
		while(last != null) {
			ByteSpec candidate = constantOverwrite.containsKey(last) ? constantOverwrite.get(last) : last;
			extended.add(candidate);
			last = last.getPredecessor();
		}
		Collections.reverse(extended);
		return extended.toArray(new ByteSpec[0]);
	}
	
	public int getLength(ByteBuffer payload) {
		ByteSpec[] specs = getByteSpec();
		ByteSpec last = specs[specs.length-1];
		return last.getBegin(payload) + last.getLength(payload);
	}
	
	public static ModelAMessageType<?> getTypeById(byte id) {
		switch(id) {
		case 0x01:
			return ModelADataMessage.ModelADataMessageType.TYPE;
		case 0x02:
			return ModelASetupMessage.ModelASetupMessageType.TYPE;
		case 0x04:
			return ModelACANStatusMessage.ModelACANStatusMessageType.TYPE;
		default:
			throw new IllegalArgumentException(String.format("Unknown message type 0x%x", id));
		}
	}
	
	public String getName() {
		return getClass().getSimpleName();
	}
	
	public abstract VariableByteSpec getChecksum();
	
	public abstract T readMessage(InputStream is) throws IOException;
	
	protected void read(ByteBuffer buff, InputStream is, ByteSpec startAt) throws IOException {
		boolean started = false;
		for(ByteSpec s : getByteSpec()) {
			if(startAt == s || started) {
				started = true;
				int length = s.getLength(buff);
				int waitCount = 10;
				while(is.available() < length && waitCount > 0) {
					try {
						Thread.sleep(0, 500*1000);
					} catch (InterruptedException e) {
						// Ignore
					}
					waitCount --;
				}
				if(waitCount == 0) {
					throw new IOException("Read timed out");
				}
				byte[] bytes = new byte[length];
				int bytesRead = is.read(bytes);
				if(bytesRead != length) {
					Log.error("Not exptected");
				}
				buff.put(bytes);
			}
		}
	}
}
