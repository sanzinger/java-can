package at.sanzinger.can.modela;

import java.nio.ByteBuffer;

import at.sanzinger.can.message.ByteSpec;
import at.sanzinger.can.message.ConstantByteSpec;
import at.sanzinger.can.message.MessageType;
import at.sanzinger.can.message.VariableByteSpec;

public class ModelAMessage<T extends ModelAMessage<?>> {
	private final ModelAMessageType<T> type;
	protected final ByteBuffer payload;
	
	public ModelAMessage(ModelAMessageType<T> type, ByteBuffer payload) {
		super();
		this.type = type;
		this.payload = payload;
	}
	
	public ModelAMessageType<T> getType() {
		return type;
	}
	
	protected byte calculateChecksum() {
		byte sum = 0;
		VariableByteSpec checksum = type.getChecksum();
		int len = checksum.getBegin(payload);
		for(int i = ModelAMessageType.MESSAGE_TYPE.getBegin(payload); i < len; i++) {
			sum += payload.get(i);
		}
		return sum;
	}
	
	public void emitChecksum() {
		type.getChecksum().setValue(payload, calculateChecksum());
	}
	
	public final byte[] getBody() {
		type.setConstant(payload);
		emitChecksum();
		int length = type.getLength(payload);
		byte[] result = new byte[length];
		int oldPos = payload.position();
		payload.get(result, 0, length);
		payload.position(oldPos);
		return result;
	}

	public boolean verify() {
		return calculateChecksum() == getChecksum();
	}
	
	public byte getChecksum() {
		return (byte)type.getChecksum().getValue(payload);
	}
	
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(type.getName());
		sb.append("[");
		for(ByteSpec s : type.getByteSpec()) {
			sb.append(s.format(payload));
			sb.append(", ");
		}
		return sb.substring(0, sb.length()-2) + "]";
	}
	
	/**
	 * General Format (20 bytes fixed size message block)
	 * <pre>
	 * ,---,----------- Start sequence, consumed/generated by {@link ModelAAdapter}
	 * |   |  ,-------- Message type (01: data, 02: config)
	 * |   |  | ,---------------------------------------------,--- Payload
	 * |   |  | |                                             |  ,- Checksum
	 * AA 55 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 	
	 * </pre>
	 */
	public static abstract class ModelAMessageType<T extends ModelAMessage<?>> extends MessageType<T> {
		public static final ConstantByteSpec HEADER;
		public static final VariableByteSpec MESSAGE_TYPE;
		
		public static final ByteSpec[] SPEC = new ByteSpec[] {
			HEADER       = new ConstantByteSpec("HEADER",       null, c(2), 0x55AA),
			MESSAGE_TYPE = new VariableByteSpec("MESSAGE_TYPE", HEADER, c(1)),
		};

		public abstract VariableByteSpec getChecksum();
		
		public static ModelAMessageType<?> getTypeById(byte id) {
			switch(id) {
			case 0x01:
				return ModelADataMessage.ModelADataMessageType.TYPE;
			case 0x02:
				return ModelASetupMessage.ModelASetupMessageType.TYPE;
			case 0x04:
				return ModelACANStatusMessage.ModelACANStatusMessageType.TYPE;
			default:
				throw new IllegalArgumentException(String.format("Unknown message type 0x%x", id));
			}
		}
	}
}
